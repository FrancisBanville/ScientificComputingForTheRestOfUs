---
title: Genetic algorithm
weight: 1
status: construction
packages:
  - StatsPlots
  - StatsKit
  - Statistics
concepts:
  - data frames
  - generic code
  - type system
---

Genetic algorithm is a heuristic that takes heavy inspiration from evolutionary
biology, to explore a space of parameters rapidly and converge to an optimum.
Every solution is a "genome", and the combinations can undergo mutation and
recombination. By simulating a process of reproduction, over sufficiently many
generation, this heuristic usually gives very good results. It is also simple to
implement, and this is what we will do!

A genetic algorithm works by measuring the fitness of a solution (*i.e.* its fit
to a problem we have defined). We can then pick solution for "reproduction",
which involves recombination at various points in the "genome", and finally a
step for the mutation of offspring. There are an almost infinite number of
variations at each of these steps, but we will limit ourselves to a simple case
here.

Specifically, we will use the `DataFrames` and `CSV` package (installed in
`StatsKit`) to read a table containing metabolic rates of species, and then use
genetic algorithm to try and find out the scaling exponent linking mass to the
field metabolic rate.

[Source of data](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/1365-2656.12086)

```julia
using StatsKit
using StatsPlots
url = "http://sciencecomputing.io/data/metabolicrates.csv"
tmp = download(url)
rates = CSV.read("static/data/metabolicrates.csv") # TODO use tmp instead
```

Let's have a look at the names of the columns:

```julia
names(rates)
```

We will replace the last two names:

```julia
rename!(rates, names(rates)[end-1] => :mass)
rename!(rates, names(rates)[end] => :fmr)
names(rates)
```

Much better! Now let's try to figure out the relationship between the last two
variables:

```julia; fig_cap="Relationship between field metabolic rate and mass - this is a neat log-log relationship, and so linear regression will give us the exponent."
scatter(rates[:mass], rates[:fmr], c=:teal, leg=false, msc=:transparent)
xaxis!(:log10, "Mass (kg)")
yaxis!(:log10, "Field Metabolic Rate (kj per day)")
```

Neat! This is a log-log relationship, so we can represent this problem as
$\text{log}_{10}(\text{FMR}) ∝ m\times\text{log}_{10}(\text{M})+b$.

{{> callout information <}}
In this capstone, we will try to write a very general code for genetic
algorithms. It is possible to come up with a more specific code, but spending
time to think about making code general is almost always wise, since it means we
can seamlessly re-use already written code.
{{> /callout <}}

Genetic algorithms represent the state of the problem as "genomes", which here
will be composed of two genes: $m$ and $b$. There are a few decisions we need to
take already: how large is our initial population, and how much standing
variation do we have?

Just to be a little fancier than usual, we will define a *type* for our genomes:

```julia
mutable struct Genome
  m::Float64
  b::Float64
end
```

{{> callout information <}}
Defining a new type is *absolutely not* necessary. We are only doing it to show
some interesting features of Julia.
{{> /callout <}}

This means that our population will be of the type `Vector{Genome}`. Now, we
will *add methods* to some of Julia's existing function, so we can write code
that will read exactly like native code would:

```julia
import Base: zero
zero(::Type{Genome}) = Genome(0.0, 0.0)
```

Because we have created a `zero` method for the `Genome` type, we can create our
population:

```julia
population_size = 10_000
population = zeros(Genome, population_size)
population[1:5]
```

To have a slightly more pleasing display, we can also overload the `show`
function:

```julia
import Base: show
show(io::IO, g::Genome) = "ŷ = $(round(g.m; digits=3))×x + $(round(g.b; digits=3))"
```

And we are now ready to start. At this point, it is useful to outline the
general structure of the genetic algorithm:

```julia
function GA(population::Vector{T}, fitness::Function, mutation!::Function, generations=1_000) where {T}
  for generation in 1:generations
    fitnesses = fitness.(population)
    population = sample(population, weights(fitnesses), length(population), replace=true)
    mutation!.(population)
  end
  return population
end
```

Wouldn't it be cool if the real code was actually that simple?

What if I told you this *is* the real code? To make it work, we need to do two
things. First, we need to define a `fitness` function, which, given an input
(here, a `Genome`), will return its "score". Second, we need to define a
`mutation!` function, which will *modify* a genome.

The fitness function can be defined as follows:

```julia
function fmr_fitness(g::Genome)
  
end
```
