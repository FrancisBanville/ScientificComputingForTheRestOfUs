---
title: Avoiding mistakes
weight: 3
status: construction
concepts: [defensive programming, writing functions, assertion, unit testing]
packages: [Test, Statistics]
meta:
  issue: 19
  label: "lesson:defensive"
---

## We can't avoid mistakes

But we can work as cautiously as possible, to make sure we catch them in time.
It is always better to try and fail to run something, than to have the operation
keep going and accumulating mistakes.

There are four types of mistakes to look out for: mistakes in the code,
confusing interface, issues with arguments, and lack of integration. Some are
caused by the programmer, and some are caused by the user. But in the context of
writing code for science, the programmer and the user are often the same person,
and so passing the blame around ends up being a very frustrating exercise. Even
if it were not the case, user mistakes can come from sub-optimal design. It is
crucial to work in a way that protects everyone against mistakes.

{{% callout opinion %}}
One of our *golden rule* is "fail early, fail often, and fail explicitely" -- it
is frustrating to have to restart an analysis, but this is preferable to running
an analysis that keeps accumulating issues we may or may not detect!
{{% /callout %}}

In this lesson, you may note that we will switch perspective frequently, from
user to developper. This is because, in our own experience, this is a fair
representation of the way we work. We try to write something (developper), then
apply it to a specific problem (user), then figure out there is an issue and
switch back to developper mode.

## After this lesson, you will be able to ...

- ... use defensive programming
- ... write basic tests to ensure that the program fails when it should
- ... think about function design in a way that minimizes confusion

But let's do something a little bit different. Instead of writing a function, we
will start by thinking about its behavior. In this example, we want to write a
function that will calculate an average. That's it. Specifically, it will
calculate the singal-to-noise ration in an array of numbers, using the S = μ/σ
expression, where μ is the average and σ the standard deviation.

What we will do is *declare* the function, but put nothing in it -- in each of
the sections, we will add a few lines to the function, to make it *work*. For
now, we want a function that does *nothing*.

```julia
function snr(x::Vector{T}) where {T <: Number}
end
```

## Using the wrong arguments

The first thing that can go wrong with this function is calling it with the
wrong arguments. In a sense, we have limited this risk because we took advantage
of Julia's type annotation system, and so we can *only* call our function when
the argument is an array of numbers.

But with the definition of signal-to-noise ratio we picked, it only makes sense
to apply this function when all elements of `x` are *non-negative*. So this is
the first thing our function should check. But instead of changing the function,
we will first *test* its behavior:

```julia
using Test
@test_throws ArgumentError snr([-1.0, 1.0, 2.0])
@test_nowarn snr([0.0, 1.0, 2.0])
```

## Confusing interface

## Mistakes in the code


## Lack of integration

- calling wrong function
- running with bad arguments
- mistake in functions
- integration issues
